<?php

declare(strict_types=1);

use PHPMailer\PHPMailer\PHPMailer;
use Dotenv\Dotenv;

use \Ds\Vector;

use StudentAssignmentScheduler\Utils\{PdfAssignmentFormWriter, PdfScheduleWriter, MailSender};
use StudentAssignmentScheduler\Models\ListOfContacts;

use function StudentAssignmentScheduler\Functions\{
    workbookParserImplementation,
    createJsonSchedulesFromWorkbooks,
    sendEmails,
    decryptedPassword,
    scheduleRecipientError,
    contactSetupError,
    importAssignments,
    importSchedule,
    generateContactsFile,
    CLI\writeAssignmentForms,
    CLI\createJsonAssignments,
    CLI\yes,
    CLI\no,
    CLI\red,
    CLI\green,
    CLI\prompt,
    CLI\jsonScheduleCreationNotification,
    CLI\setupContacts,
    CLI\setupEmail
};

///////////////////////
//
//   BOOTSTRAPPING
//
//////////////////////

// run installation script if needed
file_exists("vendor")
    || system("sh bin/install.sh");

require "autoload.php";

// load configuration files
$config_path = "config/";
$config_file = "${config_path}config.php";
$config = require $config_file;
$path_config = require "${config_path}path_config.php";
$schedule_recipients_config_file = "${config_path}schedule_recipients.php";
$contacts_file = "${config_path}contacts.php";


/////////////////////////
//
// User configuration
//
/////////////////////////

// the contacts file and schedule recipients must be setup first

// 1. Contacts
// does the user want to setup contacts now
file_exists($contacts_file)
    || !empty($contacts = require $contacts_file)
    || setupContacts($contacts_file);

// 2. Who should receive the full schedule for the month
// does the user want to setup schedule recipients now
file_exists($schedule_recipients_config_file)
    || !empty($schedule_recipients = require $schedule_recipients_config_file)
    || setupScheduleRecipients($schedule_recipients_config_file);


// 3. email configuration
// there must be a .env file with email configuration
$env_dir = __DIR__;
$Dotenv = new Dotenv($env_dir);

try {
    $Dotenv->load();
} catch (\Dotenv\Exception\InvalidPathException $e) {

    setupEmail($env_dir);

    $Dotenv = new Dotenv($env_dir);
    $Dotenv->load();
}

$Dotenv->required([
    "from_email",
    "from_email_password",
    "from_email_nonce",
    "from_email_key",
    "smtp_host"
]);

// make required directories
$required_directories = new Vector([
    "data/assignments",
    "data/forms",
    "data/schedules",
    "workbooks/pdf",
    "workbooks/rtf",
    "tmp",
    "log"
]);

$make_dir = function (string $dir) {
    $path = __DIR__ . DIRECTORY_SEPARATOR . $dir;
    file_exists($path) || mkdir($path, 0770, true);
};
$required_directories->map($make_dir);

$WorkbookParser = workbookParserImplementation($config);
$AssignmentFormWriter = new PdfAssignmentFormWriter($config);
$ScheduleWriter = new PdfScheduleWriter($config);
$ListOfContacts = new ListOfContacts();
$MailSender = new MailSender(
    new PHPMailer(true),
    getenv("from_email"),
    decryptedPassword(),
    getenv("smtp_host")
);



///////////////////////
//
//   INITIALIZE PATHS
//
//////////////////////

$path_to_workbooks = "{$path_config["path_to_workbooks"]}/{$config["workbook_format"]}";
$path_to_data = $path_config["path_to_data"];

/**
 * These strings will be modified by an anonymous function.
 *
 * The final destination of the data is determined dynamically.
 * For example, the year of the schedule may be appended to the path
 * in order to make it the directory where this data is saved.
 */
$path_to_json_schedules = "{$path_config["path_to_data"]}/";
$path_to_json_assignments = "{$path_config["path_to_assignments"]}/";



/**
 * Parses the workbooks into data that will be required
 * later in the application.
 *
 * The return value of this function is required since
 * the schedule's year is used when creating assignments.
 * The years are used in a 'Set' so that there will be no
 * duplicates.  The last week of December's schedule may be
 * in the following year, in which case both years will
 * be required when making assignments.
 */
$SetOfYearsSchedulesWereIn = createJsonSchedulesFromWorkbooks(
    $WorkbookParser,
    $path_to_workbooks,
    $path_to_data,
    jsonScheduleCreationNotification()
);



/**
 * This function is used to abort creating assignments.
 *
 * It assumes that there will be a PDF schedule with a basename
 * being the month scheduled.  This should be changed to allow
 * for changes in the future.  For example, the user may want to
 * configure the application to produce schedules in other formats.
 *
 * An anonymous function is used in order to use variables that
 * are in the parent scope with out requiring partial application.
 */
$hasScheduleAlreadyBeenCompleted = function (string $month) use ($path_config) {
    $schedule_filename = "{$path_config["path_to_schedules"]}/${month}.pdf";

    return file_exists($schedule_filename);
};



/**
 * Used to allow the user to create assignments.
 *
 * Most of the UI of the application is in this function.
 *
 * An anonymous function is used in order to use variables that
 * are in the parent scope with out requiring partial application.
 * This function also modifies strings that are in the parent scope
 * by importing references to the strings.
 */

$assignmentsWereMade = false;

$createJsonAssignments = function (
    $carry,
    int $year
) use (
    $AssignmentFormWriter,
    &$path_to_json_schedules,
    &$path_to_json_assignments,
    &$assignmentsWereMade,
    $hasScheduleAlreadyBeenCompleted
) {

    // Append the year to the paths
    $path_to_json_schedules .= $year;
    $path_to_json_assignments .= $year;

    /**
     * Interact with the user of the application to schedule assignments.
     *
     * A json file is created for each week of assignments.
     */
     $assignmentsWereMade = createJsonAssignments(
        $path_to_json_schedules,
        $path_to_json_assignments,
        $hasScheduleAlreadyBeenCompleted
    );
};



/**
 * Create assignments for each year the schedules are in.
 *
 * The assignment creating function is where most of the
 * user interfacing of the application is.
 */
$SetOfYearsSchedulesWereIn->remove(null);
$SetOfYearsSchedulesWereIn->reduce($createJsonAssignments);



/**
 * Create assignment forms.
 *
 * The json files representing weeks of assignments are used
 * to generate pdf assignment forms.
 */
$year = $SetOfYearsSchedulesWereIn->get(0);

// Abort if assignments were not made
$assignmentsWereMade
    || exit(green("No assignments were made. Good Bye.\r\n"));

$which_months = writeAssignmentForms(
    $AssignmentFormWriter,
    $path_to_json_assignments,
    $path_to_json_schedules,
    $hasScheduleAlreadyBeenCompleted,
    $year
);


// Abort if assignment forms were not written
current($which_months)
    || exit(green("It looks like you are all up-to-date.\r\nNo schedules were created.  Good Bye\r\n"));



/**
 * Create the schedule for the month.
 *
 * Uses the json schedule and the json assignment files
 * to generate a schedule (i.e. pdf file) for the month.
 */
$month = current($which_months);
$filename_of_schedule = "${month}.json";

$assignments = importAssignments($month, $path_to_json_assignments);
$schedule = importSchedule($filename_of_schedule, $path_to_json_schedules);

$schedule_filename = $ScheduleWriter->create($assignments, $schedule, $month);



/**
 * Email the assignments and schedule.
 *
 * Determine if the user wants to send them.
 */
$user_response = readline(
    prompt("Do you want to send the emails")
);

yes($user_response)
    && sendEmails(
        $MailSender,
        $ListOfContacts,
        $contacts,
        $config["assignment_forms_destination"],
        $schedule_recipients,
        $schedule_filename
    );

no($user_response)
    && print red("Ok. Emails were not sent.\r\n");

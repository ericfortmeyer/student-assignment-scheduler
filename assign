<?php

declare(strict_types=1);

use PHPMailer\PHPMailer\PHPMailer;
use Dotenv\Dotenv;

use StudentAssignmentScheduler\Utils\{PdfAssignmentFormWriter, PdfScheduleWriter, MailSender};
use StudentAssignmentScheduler\Models\ListOfContacts;

use function StudentAssignmentScheduler\Functions\{
    workbookParserImplementation,
    createJsonSchedulesFromWorkbooks,
    sendEmails,
    decryptedPassword,
    scheduleRecipientError,
    contactSetupError,
    importAssignments,
    importSchedule,
    CLI\writeAssignmentForms,
    CLI\createJsonAssignments,
    CLI\yes,
    CLI\no,
    CLI\red,
    CLI\green,
    CLI\prompt,
    CLI\jsonScheduleCreationNotification
};

///////////////////////
//
//   BOOTSTRAPPING
//
//////////////////////

// run installation script if needed
file_exists("vendor")
    || print("Installing dependencies...\r\n")
    && system("sh bin/install.sh");

require "autoload.php";

// load configuration files
$config_path = "config/";
$config_file = "${config_path}config.php";
$config = require $config_file;
$path_config = require "${config_path}path_config.php";
$schedule_recipients_config_file = "${config_path}schedule_recipients.php";
$contacts_file = "${config_path}contacts.php";

// does the user want to setup contacts now
if (!file_exists($contacts_file)) {
    $should_add_contacts = readline(prompt("Contacts must be setup first.  Are you ready to set them up?"));

    yes($should_add_contacts)
        && setupContacts($contacts_file);
    
    no($should_add_contacts)
        && red("Ok. You can set them up later.")
        && file_put_contents($contacts_file, "<?php" . PHP_EOL . "return [];" . PHP_EOL);
}

// the contacts file and schedule recipients must be setup first
empty($contacts = require $contacts_file)
    && exit(red(contactSetupError($contacts_file)));
empty($schedule_recipients = require $schedule_recipients_config_file)
    && exit(red(scheduleRecipientError($schedule_recipients_config_file)));

$Dotenv = new Dotenv(__DIR__);
$Dotenv->load();
$Dotenv->required([
    "from_email",
    "from_email_password",
    "from_email_nonce",
    "from_email_key",
    "smtp_host"
]);

$WorkbookParser = workbookParserImplementation($config);
$AssignmentFormWriter = new PdfAssignmentFormWriter($config);
$ScheduleWriter = new PdfScheduleWriter($config);
$ListOfContacts = new ListOfContacts();
$MailSender = new MailSender(
    new PHPMailer(true),
    getenv("from_email"),
    decryptedPassword(),
    getenv("smtp_host")
);



///////////////////////
//
//   INITIALIZE PATHS
//
//////////////////////

$path_to_workbooks = "{$path_config["path_to_workbooks"]}/{$config["workbook_format"]}";
$path_to_data = $path_config["path_to_data"];

/**
 * These strings will be modified by an anonymous function.
 *
 * The final destination of the data is determined dynamically.
 * For example, the year of the schedule may be appended to the path
 * in order to make it the directory where this data is saved.
 */
$path_to_json_schedules = "{$path_config["path_to_data"]}/";
$path_to_json_assignments = "{$path_config["path_to_assignments"]}/";



/**
 * Parses the workbooks into data that will be required
 * later in the application.
 *
 * The return value of this function is required since
 * the schedule's year is used when creating assignments.
 * The years are used in a 'Set' so that there will be no
 * duplicates.  The last week of December's schedule may be
 * in the following year, in which case both years will
 * be required when making assignments.
 */
$SetOfYearsSchedulesWereIn = createJsonSchedulesFromWorkbooks(
    $WorkbookParser,
    $path_to_workbooks,
    $path_to_data,
    jsonScheduleCreationNotification()
);



/**
 * This function is used to abort creating assignments.
 *
 * It assumes that there will be a PDF schedule with a basename
 * being the month scheduled.  This should be changed to allow
 * for changes in the future.  For example, the user may want to
 * configure the application to produce schedules in other formats.
 *
 * An anonymous function is used in order to use variables that
 * are in the parent scope with out requiring partial application.
 */
$hasScheduleAlreadyBeenCompleted = function (string $month) use ($path_config) {
    $schedule_filename = "{$path_config["path_to_schedules"]}/${month}.pdf";

    return file_exists($schedule_filename);
};



/**
 * Used to allow the user to create assignments.
 *
 * Most of the UI of the application is in this function.
 *
 * An anonymous function is used in order to use variables that
 * are in the parent scope with out requiring partial application.
 * This function also modifies strings that are in the parent scope
 * by importing references to the strings.
 */

$assignmentsWereMade = false;

$createJsonAssignments = function (
    $carry,
    int $year
) use (
    $AssignmentFormWriter,
    &$path_to_json_schedules,
    &$path_to_json_assignments,
    &$assignmentsWereMade,
    $hasScheduleAlreadyBeenCompleted
) {

    // Append the year to the paths
    $path_to_json_schedules .= $year;
    $path_to_json_assignments .= $year;

    /**
     * Interact with the user of the application to schedule assignments.
     *
     * A json file is created for each week of assignments.
     */
     $assignmentsWereMade = createJsonAssignments(
        $path_to_json_schedules,
        $path_to_json_assignments,
        $hasScheduleAlreadyBeenCompleted
    );
};



/**
 * Create assignments for each year the schedules are in.
 *
 * The assignment creating function is where most of the
 * user interfacing of the application is.
 */
$SetOfYearsSchedulesWereIn->remove(null);
$SetOfYearsSchedulesWereIn->reduce($createJsonAssignments);



/**
 * Create assignment forms.
 *
 * The json files representing weeks of assignments are used
 * to generate pdf assignment forms.
 */
$year = $SetOfYearsSchedulesWereIn->get(0);

// Abort if assignments were not made
$assignmentsWereMade
    || exit(green("No assignments were made. Good Bye.\r\n"));

$which_months = writeAssignmentForms(
    $AssignmentFormWriter,
    $path_to_json_assignments,
    $path_to_json_schedules,
    $hasScheduleAlreadyBeenCompleted,
    $year
);


// Abort if assignment forms were not written
current($which_months)
    || exit(green("It looks like you are all up-to-date.\r\nNo schedules were created.  Good Bye\r\n"));



/**
 * Create the schedule for the month.
 *
 * Uses the json schedule and the json assignment files
 * to generate a schedule (i.e. pdf file) for the month.
 */
$month = current($which_months);
$filename_of_schedule = "${month}.json";

$assignments = importAssignments($month, $path_to_json_assignments);
$schedule = importSchedule($filename_of_schedule, $path_to_json_schedules);

$schedule_filename = $ScheduleWriter->create($assignments, $schedule, $month);



/**
 * Email the assignments and schedule.
 *
 * Determine if the user wants to send them.
 */
$user_response = readline(
    prompt("Do you want to send the emails")
);

yes($user_response)
    && sendEmails(
        $MailSender,
        $ListOfContacts,
        $contacts,
        $config["assignment_forms_destination"],
        $schedule_recipients,
        $schedule_filename
    );

no($user_response)
    && print red("Ok. Emails were not sent.\r\n");
